{

  open Lexing
  open Printf

  (* Concatenation with a newline in the middle. *)

  let (^/^) s1 s2 = s1 ^ "\n" ^ s2

  (* This function is analagous to [MenhirLib.LexerUtil.range] but does not
     print the file name or the trailing colon and newline. *)
  let range' (pos1, pos2) =
    let line = pos1.pos_lnum in
    let char1 = pos1.pos_cnum - pos1.pos_bol in
    let char2 = pos2.pos_cnum - pos1.pos_bol in (* yes, [pos1.pos_bol] *)
    sprintf "line %d, characters %d-%d"
      line char1 char2
      (* use [char1 + 1] and [char2 + 1] if *not* using Caml mode *)

  (* This global reference gives us access to the content of the current file.
     Using global mutable state is not very elegant, but avoids the noise that
     would be caused by explicit parameter passing. An alternative would be to
     parameterize every auxiliary function and every semantic action with the
     content of the file. *)

  let content =
    ref None

  open MenhirLib.ErrorReports

  (* [slice w] extracts and returns the input slice delimited by the pair
     of positions [w]. The resulting string is clean and fits on a line. *)

  let slice (w : position * position) =
    extract (Option.get !content) w
    |> sanitize
    |> compress
    |> shorten 32

  (* [read thing w] indicates that a "thing" has been read, displays the
     positions, and displays the corresponding input slice. *)

  let read (thing : string) (w : position * position) =
    sprintf "%s has been read (%s):\n  %s\n"
      thing (range' w) (slice w)

  (* Names for various things. *)

  let arrow  = read "An arrow symbol"
  let binop  = read "A binary operator"
  let comma  = read "A comma"
  let expr   = read "An expression"
  let ffun   = read "The keyword `fun`"
  let lparen = read "An opening parenthesis"
  let pat    = read "A pattern"

}

rule error_message = parse error (main)

| e=expr; o=PLUS / _* . expr _*
| e=expr; o=MINUS / _* . expr _*
| e=expr; o=DIV / _* . expr _*
| e=expr; o=TIMES / _* . expr _*
    {
      expr ($startloc(e), $endloc(e)) ^
      binop ($startloc(o), $endloc(o)) ^
      "An expression is now expected."
    }

| l=LPAREN / _* . expr _*
    {
      lparen ($startloc(l), $endloc(l)) ^
      "An expression is now expected."
    }

| l=LPAREN; e=[expr / _* . RPAREN]
    {
      lparen ($startloc(l), $endloc(l)) ^
      expr ($startloc(e), $endloc(e)) ^
      "If this expression is complete," ^/^
      "a closing parenthesis or a comma is now expected."
    }

| l=LPAREN; e=expr; c=COMMA / _* . expr _*
    {
      lparen ($startloc(l), $endloc(l)) ^
      expr ($startloc(e), $endloc(e)) ^
      comma ($startloc(c), $endloc(c)) ^
      "An expression is now expected."
    }

| l=LPAREN; e1=expr; c=COMMA; e2=[expr / _* . RPAREN]
    {
      lparen ($startloc(l), $endloc(l)) ^
      expr ($startloc(e1), $endloc(e1)) ^
      comma ($startloc(c), $endloc(c)) ^
      expr ($startloc(e2), $endloc(e2)) ^
      "A closing parenthesis is now expected."
    }

(* TODO lrgrep tells me this branch is useless, but it shouldn't be! see test/bad/test07.in *)
| f=FUN; p=[pat / _* . ARROW _*]
    {
      ffun ($startloc(f), $endloc(f)) ^
      pat ($startloc(p), $endloc(p)) ^
      "An arrow symbol is now expected."
    }

| f=FUN; p=pat; a=ARROW / _* . expr _*
    {
      ffun ($startloc(f), $endloc(f)) ^
      pat ($startloc(p), $endloc(p)) ^
      arrow ($startloc(a), $endloc(a)) ^
      "An expression is now expected."
    }

(* TODO this clause is apparently reachable
        but if I add square brackets around it
        then lrgrep says it is unreachable.
        I do not understand this: the square brackets
        should allow it to match MORE situations. *)
| / _* . pat _*
    {
      "A pattern is now expected."
    }

| l=LPAREN / _* . pat _*
    {
      lparen ($startloc(l), $endloc(l)) ^
      "A pattern is now expected."
    }

| l=LPAREN; p=[pat / _* . RPAREN]
    {
      lparen ($startloc(l), $endloc(l)) ^
      pat ($startloc(p), $endloc(p)) ^
      "If this pattern is complete," ^/^
      "a closing parenthesis or a comma is now expected."
    }

| l=LPAREN; p1=pat; c=COMMA; p2=[pat / _* . RPAREN]
    {
      lparen ($startloc(l), $endloc(l)) ^
      pat ($startloc(p1), $endloc(p1)) ^
      comma ($startloc(c), $endloc(c)) ^
      pat ($startloc(p2), $endloc(p2)) ^
      "A closing parenthesis is now expected."
    }

| e=[expr / _* . EOF]
    {
      expr ($startloc(e), $endloc(e)) ^
      "If this expression is complete, the end of the file is now expected."
    }

(* TODO this clause is a copy of the previous one so it must be unreachable,
        yet lrgrep says nothing *)
| e=[expr / _* . EOF]
    {
      assert false
    }

| / _* . main
    (* The file is empty or begins with an unacceptable token. *)
    {
      "An expression is now expected."
    }
