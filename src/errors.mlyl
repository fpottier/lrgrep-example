{

  open Lexing
  open Printf

  (* This function is analagous to [MenhirLib.LexerUtil.range] but does not
     print the file name or the trailing colon and newline. *)
  let range' (pos1, pos2) =
    let line = pos1.pos_lnum in
    let char1 = pos1.pos_cnum - pos1.pos_bol in
    let char2 = pos2.pos_cnum - pos1.pos_bol in (* yes, [pos1.pos_bol] *)
    sprintf "line %d, characters %d-%d"
      line char1 char2
      (* use [char1 + 1] and [char2 + 1] if *not* using Caml mode *)

  (* This global reference gives us access to the content of the current
     file. Using global mutable state is not very elegant. An alternative
     would be to parameterize every semantic action (below) with [content].
     TODO do this, once lrgrep supports it *)

  let content =
    ref None

  open MenhirLib.ErrorReports

  let slice (w : position * position) =
    extract (Option.get !content) w
    |> sanitize
    |> compress
    |> shorten 32

}

rule error_message = parse error (main)
| / _* . expr _*
    { "Expecting an expression" }
| w = LPAREN; [expr / _* . RPAREN]
    { let w = $startloc(w), $endloc(w) in
      sprintf "Expecting a closing parenthesis (opened at %s)" (range' w) }
| w = [expr / _* . EOF]
    { let w = $startloc(w), $endloc(w) in
      sprintf "An expression has been recognized (%s):\n  %s\n"
        (range' w) (slice w) ^
      sprintf "If this expression is complete, the end of the file is now expected."}
