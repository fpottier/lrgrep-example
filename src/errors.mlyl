{

  open Lexing
  open Printf

  (* Concatenation with a newline in the middle. *)

  let (^/^) s1 s2 = s1 ^ "\n" ^ s2

  (* This function is analagous to [MenhirLib.LexerUtil.range] but does not
     print the file name or the trailing colon and newline. *)
  let range' (pos1, pos2) =
    let line = pos1.pos_lnum in
    let char1 = pos1.pos_cnum - pos1.pos_bol in
    let char2 = pos2.pos_cnum - pos1.pos_bol in (* yes, [pos1.pos_bol] *)
    sprintf "line %d, characters %d-%d"
      line char1 char2
      (* use [char1 + 1] and [char2 + 1] if *not* using Caml mode *)

  (* This global reference gives us access to the content of the current file.
     Using global mutable state is not very elegant, but avoids the noise that
     would be caused by explicit parameter passing. An alternative would be to
     parameterize every auxiliary function and every semantic action with the
     content of the file. *)

  let content =
    ref None

  open MenhirLib.ErrorReports

  (* [slice w] extracts and returns the input slice delimited by the pair
     of positions [w]. The resulting string is clean and fits on a line. *)

  let slice (w : position * position) =
    extract (Option.get !content) w
    |> sanitize
    |> compress
    |> shorten 32

  (* [read thing w] indicates that a "thing" has been read, displays the
     positions, and displays the corresponding input slice. *)

  let read (thing : string) (w : position * position) =
    sprintf "%s has been read (%s):\n  %s\n"
      thing (range' w) (slice w)

  (* Names for various things. *)

  let binop  = read "A binary operator"
  let decl   = read "A declaration"
  let equal  = read "An equals sign"
  let expr   = read "An expression"
  let ident  = read "An identifier"
  let letk   = read "A `let` keyword"
  let lparen = read "An opening parenthesis"

  (* This higher-order function is useful when the beginning of a thing
     has been recognized. *)

  let beginning thing w =
    "The beginning of " ^ String.lowercase_ascii (thing w)

}

rule error_message = parse error (main)

| / _* . main
    (* Nothing has been read, and [main] is expected. This means that
       the file is empty or begins with an unacceptable token. *)
    {
      "A declaration is now expected."
    }

| l=LET
    (* A [let] keyword has been read. *)
    {
      beginning decl $positions(l) ^
      "An identifier is now expected."
    }

| l=LET; i=IDENT
    (* A [let] keyword and an identifier have been read. *)
    {
      beginning decl ($startpos(l), $endpos(i)) ^
      "An equals sign `=` is now expected."
    }

| l=LET; IDENT; e=EQUAL
    (* A [let] keyword, an identifier, and an equals sign have been read. *)
    {
      beginning decl ($startpos(l), $endpos(e)) ^
      "An expression is now expected."
    }

| d=[declaration]
    (* (Some input that can be reduced to) a declaration has been read. *)
    {
      decl $positions(d) ^
      "If this declaration is complete, then" ^/^
      "another declaration (or the end of the file) is now expected."
    }

| e=expr; o=PLUS
| e=expr; o=MINUS
| e=expr; o=DIV
| e=expr; o=TIMES
| e=expr; o=SEMI
    (* An expression, followed with a binary operator, has been read. *)
    {
      expr $positions(e) ^
      binop $positions(o) ^
      "An expression is now expected."
    }

| l=LPAREN / _* . expr _*
    (* An opening parenthesis has been read, in a context where an expression
       is now expected. *)
    {
      lparen $positions(l) ^
      "An expression is now expected."
    }

| l=LPAREN; e=[expr]
    (* An opening parenthesis followed with (some input that can be reduced to)
       an expression has been read. *)
    {
      lparen $positions(l) ^
      expr $positions(e) ^
      "If this expression is complete," ^/^
      "a closing parenthesis is now expected."
    }
